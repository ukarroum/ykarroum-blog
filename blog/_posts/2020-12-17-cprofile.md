---
layout: post
title: 'Python Internals Serie : cProfile'
---

In this article, we will revisit _CPython_ code. This time we'll dive into cProfile's code to have more insights about its interal functionning.

I'll try to explain every notion used in this article and give links to sources whenevr possible, basic knowledge of Python and C is recommended but not mandatory.

## cProfile

cProfile is, well, a profiler. More seriously a profiler is a tool that can help us to determine how much time is spent in each function of our program.

This is especially useful if you want to decrease the running time of a program, using a profiler can help you find the botelneck and decide on which function you should invest developping time.

Anectodotal fact : i used to work on a ptoject that used Machine Learning in Python, and one of the tasks i was assigned was to optimize the time execution. Intuitively you may be tempted to optimize the learning step since it's utusally the one that take the most time, and manhy people tried without a lot of success, but after using a profiler we found that the learning part was actually very optimized and very quick (for reference we used XGBoost library) and a big chunk of the time was actually spent on pre processing steps. Which made our efforts more efficient to solve our performance issue.

There are two main types of profiling : 

- Deterministic profiling : Where you basically compute the time spent in each function, this has the advantage of being the most precise since you''re measuring exactly what you want to see, but can add a significant overhead to your program which may fake the results, of course this depends on how the profiling is done.
- statistical profiling : ....

cProfile is a deterministic profiler, but fortunatly is not slow cause ....

## Profiling a program using cProfile

using cProfile is fairly easy : 

{% highlight python %}
import cProfile
import re
cProfile.run('re.compile("foo|bar")')
{% endhighlight %}

This will print the following : 

{% highlight python %}
>>> cProfile.run('re.compile("foo|bar")')
         244 function calls (237 primitive calls) in 0.001 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.001    0.001 <string>:1(<module>)
        2    0.000    0.000    0.000    0.000 enum.py:278(__call__)
        2    0.000    0.000    0.000    0.000 enum.py:557(__new__)
        9    0.000    0.000    0.000    0.000 enum.py:654(name)
{% endhighlight %}

the columns refer to : 


> ncalls : for the number of calls.
> 
> tottime : for the total time spent in the given function (and excluding time made in calls to sub-functions)
> 
> percall : is the quotient of tottime divided by ncalls
> 
> cumtime : is the cumulative time spent in this and all subfunctions (from invocation till exit). This figure is accurate even for recursive functions.
> 
> percall : is the quotient of cumtime divided by primitive calls
> 
> filename:lineno(function) : provides the respective data of each function

You can find this and more examples in the official documentation: [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).

## cProfile : the code

Alright, without further ado, let's dive into cpython's code.

First of all, clone the repo : 

{% highlight bash %}
git clone https://github.com/python/cpython.git
{% endhighlight %}

The first entry point looks like this file : `cpython/Lib/cProfile.py`.

In this article we gonna follow our initial example, but keep in mind, that there are more ways to run cprofile, for exampel : 

{% highlight bash %}
python3 -m cProfile script.py 
{% endhighlight %}

Our run function looks pretty straightforward : 

{% highlight python %}
def run(statement, filename=None, sort=-1):
    return _pyprofile._Utils(Profile).run(statement, filename, sort)
{% endhighlight %}

`_pyprofile._Utils` refers to the class `_Utils` in the file `cpython/Lib/profile.py`.

{% highlight python %}
    def __init__(self, profiler):
        self.profiler = profiler

    def run(self, statement, filename, sort):
        prof = self.profiler()
        try:
            prof.run(statement)
        except SystemExit:
            pass
        finally:
            self._show(prof, filename, sort)
{% endhighlight %}

The _constructor_ basicaly create an attribute containin a class given as a paremeter (in our case the class is _Profile_.

The _run_ method justs run the run method of _Profile_ : 

{% highlight python %} 
    def run(self, cmd):
        import __main__
        dict = __main__.__dict__
        return self.runctx(cmd, dict, dict)
{% endhighlight %}

we import main this will basicaly import he module from which we ran our program (no idea why).

We get the dict which contains all the variables declared in our module.

In my optinion (we may check this later) this will create the same context in which we tried to run our function using _cProfile.run('fct')_.

the function then call _runctx_ : 

{% highlight python %}
    def runctx(self, cmd, globals, locals):
        self.enable()
        try:
            exec(cmd, globals, locals)
        finally:
            self.disable()
        return self
{% endhighlight %}

The _enable_, _execute_ and _disable_ functions are defined in ``
